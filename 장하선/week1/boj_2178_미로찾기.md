# 뇌구현
- 길찾기 문제이기에 방법 자체는 어렵지 않았다.
- 최단경로를 찾는 경우이기에 BFS 적용

## 문제 상황
- 처음에는 stack을 활용해 풀이하려 했으나 구현에 어려움을 겪었음
- stack으로는 샛길 있으면 거기에 머리박고 있고, 최단거리를 못 찾음
- queue 활용해서 문제 해결

## 해결 과정
- 처음에는 queue를 활용하는 방법을 찾기 위해, queue에 대한 공부를 함
- 이를 위해 백준에 있는 스택, 큐, 덱 에서 '18258 큐 2' 문제를 먼저 풀고 queue에 대한 공부를 따로 함

### queue란?
- 선입선출 기반 자료구조. BFS에서 자주 사용됨
- pyhton에서는 queue를 효과적으로 활용하기 위해 collections 모듈 내에서 deque를 제공함.

### deque란?
- deque는 양방향성을 가진 자료구조
- 길이 n의 행렬로 생각하면, index 0에서도 index n에서도 데이터를 추가/제거 가능
- list와 유사한 구조를 가지고 있음.
- 다른 점 : list에서는 append, pop, extend가 자료형 맨 끝의 데이터를 조작하는 형식. deque에서는 appendleft, popleft를 통해 맨 앞에 자료 추가가 가능
- list는 못하는거 : rotate(n)
    - n만큼 요소를 회전, deque를 시계라고 생각했을 때, n만큼 오른쪽으로 회전


> # My solution
```python
from collections import deque
n,m=map(int,input().split())
maze=[[] for _ in range(n)]
# maze와 같은 크기의 boolean type의 방문 행렬 추가
visited = [[False]*m for _ in range(n)]

# 시작점 [0,0]은 방문이 되어있는게 당연하니까 True로 만들어줌
visited[0][0]=True

# queue 활용, 현재 방문하고 있는 지점을 여기에 저장함.
queue=deque([(0,0)])

# maze에 input 받아주기
for i in range(n):
    k=input()
    for j in range(m):
        maze[i].append(int(k[j]))

# 이동을 위한 행렬. 한번 이동 시 상/하/좌/우 이동 가능하니 이를 적용
dx=[-1,1,0,0]
dy=[0,0,-1,1]

while queue:
    # queue를 x,y에 넣어주고 반환. 가장 앞에 있는 것을 반환해야 하니 popleft
    x,y=queue.popleft()
    for i in range(4):
        # 상/하/좌/우 이동
        nx,ny=x+dx[i],y+dy[i]
        # idx가 미로 밖으로 나가지 않을 때만 작업 실행
        if 0<=nx<n and 0<=ny<m:
            # 미로가 0이면 못가는 곳, 방문한 곳도 갈 필요 없으니 조건 걸기
            if maze[nx][ny]!=0 and not visited[nx][ny]:
                    # queue에 갈 수 있는 곳을 붙여줌
                    queue.append((nx,ny))
                    # 방문지역은 갔다고 표시
                    visited[nx][ny]=True
                    # 핵심! 방문하면서 간 칸 수를 maze에 덮어줌.
                    # 이것때문에 maze[nx][ny]!=0 을 사용해 주었음
                    # 막다른 길에 도달하는 경우에도 그 방향으로는 더 진행만 안하는 상태로 두고 다른 queue로 진행 가능
                    maze[nx][ny]=maze[x][y]+1
print(maze[n-1][m-1])
```

> ## 코드 실행 시 queue의 변화
input
4 6
101111
101010
101011
111011

(1, 0)
(2, 0)
(3, 0)
(3, 1)
(3, 2)
(2, 2)
(1, 2)
(0, 2)
(0, 3)
(0, 4)
(1, 4)
# 두 갈래 길 등장, (0, 5)는 막다른 길이여서 popleft해도 어차피 어디 못 가고 그 뒤 (1, 4)만 진행
(1, 4) (0, 5)
(0, 5) (2, 4)
(3, 4)
(3, 4) (2, 5)
(2, 5) (3, 5)
15